# 技能效果系统设计文档

## 设计理念

基于原子操作组合的效果系统，通过10-15个原子效果类的组合，实现289个技能效果。

## 核心概念

### 1. 原子效果 (Atomic Effect)
最小的、不可再分的效果操作单元，例如：
- 伤害修正
- 条件判断
- 状态施加
- 能力变化
- 回复效果

### 2. 组合效果 (Composite Effect)
由多个原子效果组合而成的复杂效果，例如：
- Effect 46 (先手威力提升) = ConditionalCheck(先手) + DamageModifier(+50%)
- Effect 43 (后手威力提升) = ConditionalCheck(后手) + DamageModifier(+50%)
- Effect 44 (对方异常状态威力提升) = ConditionalCheck(对方有状态) + PowerModifier(+50%)

### 3. 持续效果 (Duration Effect)
需要持续N回合的效果，通过DurationWrapper包装原子效果实现

## 原子效果类型

根据 analyze_atomic_effects.js 的分析结果，我们需要以下原子效果：

### 核心原子效果 (10个)

1. **ConditionalCheck** - 条件判断 (196次使用)
   - 先手/后手判断
   - HP阈值判断
   - 状态判断
   - 能力等级判断
   - 属性类型判断

2. **DamageModifier** - 伤害修正 (35次使用)
   - 百分比修正
   - 固定值修正
   - 倍数修正

3. **PowerModifier** - 威力修正 (29次使用)
   - 技能威力修正

4. **PriorityModifier** - 先制修正 (27次使用)
   - 速度优先级修正

5. **StatModifier** - 能力变化 (27次使用)
   - 能力等级提升/下降
   - 能力值同步/交换

6. **StatusInflictor** - 状态施加 (34次使用)
   - 异常状态施加
   - 概率触发

7. **HealEffect** - 回复效果 (28次使用)
   - HP回复
   - 百分比回复
   - 固定值回复

8. **AccuracyModifier** - 命中修正 (22次使用)
   - 命中率提升/下降

9. **CritModifier** - 暴击修正 (21次使用)
   - 暴击率修正
   - 必定暴击

10. **ImmuneEffect** - 免疫效果 (15次使用)
    - 免疫能力下降
    - 免疫异常状态
    - 免疫伤害

### 辅助原子效果 (5个)

11. **DurationWrapper** - 持续效果包装器 (91次使用)
    - 包装任何原子效果，使其持续N回合

12. **TriggerEffect** - 触发效果 (用于反击、反弹等)
    - 受到攻击时触发
    - 造成伤害时触发

13. **FixedDamageEffect** - 固定伤害
    - 秒杀
    - 固定伤害值

14. **ReflectEffect** - 反弹效果
    - 伤害反弹
    - 状态反弹

15. **SpecialEffect** - 特殊效果
    - 无限PP
    - 逃跑
    - 其他特殊机制

## 架构设计

```
IAtomicEffect (接口)
    ├── ConditionalCheck
    ├── DamageModifier
    ├── PowerModifier
    ├── PriorityModifier
    ├── StatModifier
    ├── StatusInflictor
    ├── HealEffect
    ├── AccuracyModifier
    ├── CritModifier
    ├── ImmuneEffect
    ├── DurationWrapper
    ├── TriggerEffect
    ├── FixedDamageEffect
    ├── ReflectEffect
    └── SpecialEffect

CompositeEffect (组合效果)
    - 持有多个 IAtomicEffect
    - 按顺序执行
    - 支持条件执行

EffectFactory (效果工厂)
    - 从JSON配置创建效果
    - 解析原子效果组合
    - 缓存效果实例
```

## JSON配置扩展

在现有的 skill_effects.json 基础上，添加 `atomicComposition` 字段：

```json
{
  "effectId": 46,
  "name": "先手威力提升",
  "timing": ["BEFORE_DAMAGE_CALC"],
  "atomicComposition": {
    "type": "composite",
    "atoms": [
      {
        "type": "conditional",
        "condition": "first_strike",
        "then": [
          {
            "type": "power_modifier",
            "value": 50,
            "unit": "percent"
          }
        ]
      }
    ]
  }
}
```

## 执行流程

1. **加载阶段**
   - ConfigRegistry 加载 skill_effects.json
   - EffectFactory 解析 atomicComposition
   - 创建 CompositeEffect 实例
   - 缓存到 EffectRegistry

2. **触发阶段**
   - 战斗系统在特定 timing 触发效果
   - 传入 IEffectContext
   - CompositeEffect 按顺序执行原子效果
   - 原子效果修改 context 中的值

3. **结果收集**
   - 每个原子效果返回 IEffectResult
   - 收集到 context.results
   - 战斗系统根据结果应用变化

## 优势

1. **可维护性**
   - 只需维护10-15个原子效果类
   - 新增效果只需配置JSON，无需写代码

2. **可扩展性**
   - 新增原子效果类型很容易
   - 组合方式灵活多样

3. **可测试性**
   - 原子效果独立测试
   - 组合效果通过配置测试

4. **性能**
   - 效果实例缓存
   - 按需执行
   - 避免重复创建

## 实现步骤

1. ✅ 清理旧实现
2. ⏳ 定义 IAtomicEffect 接口
3. ⏳ 实现核心原子效果类
4. ⏳ 实现 CompositeEffect
5. ⏳ 实现 EffectFactory
6. ⏳ 实现 EffectRegistry
7. ⏳ 扩展 JSON 配置
8. ⏳ 集成到战斗系统
9. ⏳ 测试验证

## 示例效果实现

### 简单效果
```typescript
// Effect 46: 先手威力提升
{
  atoms: [
    ConditionalCheck("first_strike"),
    PowerModifier(+50%)
  ]
}
```

### 复杂效果
```typescript
// Effect 53: N回合伤害倍增
{
  atoms: [
    DurationWrapper(
      duration: 3,
      effect: DamageModifier(×2)
    )
  ]
}
```

### 多条件效果
```typescript
// Effect 44: 对方异常状态威力提升
{
  atoms: [
    ConditionalCheck("target_has_status"),
    PowerModifier(+50%)
  ]
}
```
